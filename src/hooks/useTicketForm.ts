
import { useState, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';
import { toast } from 'sonner';
import { useNavigate } from 'react-router-dom';
import { useTicketNotifications } from './useTicketNotifications';

interface FormData {
  user_name: string;
  user_email: string;
  user_phone: string;
  title: string;
  description: string;
  category_id: string;
  priority_id: string;
}

interface Category {
  id: string;
  name: string;
  color: string;
  description?: string;
}

interface Priority {
  id: string;
  name: string;
  color: string;
  urgency_level: number;
}

export const useTicketForm = () => {
  const { client, user } = useAuth();
  const navigate = useNavigate();
  const { notifyNewTicket } = useTicketNotifications();
  
  const [formData, setFormData] = useState<FormData>({
    user_name: '',
    user_email: '',
    user_phone: '',
    title: '',
    description: '',
    category_id: '',
    priority_id: ''
  });

  const [files, setFiles] = useState<File[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [categories, setCategories] = useState<Category[]>([]);
  const [priorities, setPriorities] = useState<Priority[]>([]);

  const loadFormData = useCallback(async () => {
    if (client) {
      setFormData(prev => ({
        ...prev,
        user_name: client.name || '',
        user_email: client.email || '',
        user_phone: client.company || ''
      }));
    }

    try {
      const [categoriesRes, prioritiesRes] = await Promise.all([
        supabase.from('ticket_categories').select('*').order('name'),
        supabase.from('ticket_priorities').select('*').order('level')
      ]);

      if (categoriesRes.data) {
        const categoriesWithColor: Category[] = categoriesRes.data.map(cat => ({
          id: cat.id,
          name: cat.name,
          color: '#3B82F6',
          description: cat.description
        }));
        setCategories(categoriesWithColor);
      }
      
      if (prioritiesRes.data) {
        const prioritiesWithUrgency: Priority[] = prioritiesRes.data.map(priority => ({
          id: priority.id,
          name: priority.name,
          color: '#F59E0B',
          urgency_level: priority.level || 1
        }));
        setPriorities(prioritiesWithUrgency);
      }
    } catch (error) {
      console.error('Error loading form data:', error);
    }
  }, [client]);

  const handleInputChange = (field: keyof FormData, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  const handleSelectChange = (field: keyof FormData, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  const handleFileChange = (newFiles: File[]) => {
    setFiles(newFiles);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.title.trim() || !formData.description.trim()) {
      toast.error('Por favor, preencha todos os campos obrigatórios');
      return;
    }

    if (!formData.category_id || !formData.priority_id) {
      toast.error('Por favor, selecione a categoria e prioridade');
      return;
    }

    setIsLoading(true);

    try {
      // Garantir que sempre temos um status_id válido
      let statusId: string;
      
      // Buscar status "Novo" primeiro
      const { data: novoStatus } = await supabase
        .from('ticket_statuses')
        .select('id')
        .eq('name', 'Novo')
        .maybeSingle();

      if (novoStatus) {
        statusId = novoStatus.id;
      } else {
        // Se não existir "Novo", buscar "Aberto"
        const { data: abertoStatus } = await supabase
          .from('ticket_statuses')
          .select('id')
          .eq('name', 'Aberto')
          .maybeSingle();

        if (abertoStatus) {
          statusId = abertoStatus.id;
        } else {
          // Criar status padrão se não existir
          const { data: createdStatus, error: createError } = await supabase
            .from('ticket_statuses')
            .insert({ name: 'Aberto', color: '#3B82F6', is_closed: false })
            .select('id')
            .single();

          if (createError) {
            throw createError;
          }
          statusId = createdStatus.id;
        }
      }

      const ticketData = {
        ...formData,
        status_id: statusId,
        user_id: user?.id || client?.id || null,
        ticket_number: '' // Will be generated by trigger
      };

      console.log('Creating ticket with data:', ticketData);

      const { data: ticket, error: ticketError } = await supabase
        .from('tickets')
        .insert(ticketData)
        .select('*, ticket_priorities(name)')
        .single();

      if (ticketError) {
        console.error('Error creating ticket:', ticketError);
        throw ticketError;
      }

      console.log('Ticket created successfully:', ticket);

      // Upload de arquivos se houver
      if (files.length > 0) {
        console.log(`Uploading ${files.length} files...`);
        const uploadPromises = files.map(async (file) => {
          const fileName = `${ticket.id}/${Date.now()}_${file.name}`;
          
          const { error: uploadError } = await supabase.storage
            .from('ticket-attachments')
            .upload(fileName, file);

          if (uploadError) {
            console.error('Upload error:', uploadError);
            throw uploadError;
          }

          return supabase
            .from('ticket_attachments')
            .insert({
              ticket_id: ticket.id,
              filename: file.name,
              file_path: fileName,
              file_size: file.size,
              content_type: file.type
            });
        });

        await Promise.all(uploadPromises);
        console.log('Files uploaded successfully');
      }

      // Notificar equipe Ascalate sobre o novo chamado
      try {
        await notifyNewTicket.mutateAsync({
          ticketNumber: ticket.ticket_number,
          title: ticket.title,
          userName: ticket.user_name,
          userEmail: ticket.user_email,
          priority: ticket.ticket_priorities?.name || 'Não definida'
        });
      } catch (notificationError) {
        console.error('Error sending notification:', notificationError);
        // Não falha o processo se a notificação falhar
      }

      toast.success('Chamado criado com sucesso!');
      navigate('/cliente/chamados');
      
    } catch (error: any) {
      console.error('Error creating ticket:', error);
      toast.error(`Erro ao criar chamado: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return {
    formData,
    files,
    isLoading,
    categories,
    priorities,
    loadFormData,
    handleInputChange,
    handleSelectChange,
    handleFileChange,
    handleSubmit
  };
};
